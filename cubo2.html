<!DOCTYPE html>
<html>

<head>
    <title>Ej: Cilindro</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <script src="js/three.min.js"></script>
    <script>
        var scene, aspect, camera, renderer;
        var startTime = Date.now();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            var size = 10;
            var arrowSize = 1;
            var divisions = size;
            var origin = new THREE.Vector3(0, 0, 0);
            var x = new THREE.Vector3(1, 0, 0);
            var y = new THREE.Vector3(0, 1, 0);
            var z = new THREE.Vector3(0, 0, 1);
            var color1 = new THREE.Color(0xFFFFFF);
            var color2 = new THREE.Color(0x333333);
            var colorR = new THREE.Color(0xAA3333);
            var colorG = new THREE.Color(0x33AA33);
            var colorB = new THREE.Color(0x333366);

            //CREAR LAS GRILLAS PARA EL ESCENARIO
            var axesHelper = new THREE.AxesHelper(size);
            var gridHelperXY = new THREE.GridHelper(size, divisions, color1, color1);
            var gridHelperXZ = new THREE.GridHelper(size, divisions, color2, color2);
            var gridHelperYZ = new THREE.GridHelper(size, divisions, color2, color2);

            //ROTARLAS PARA QUE QUEDEN EN EL ESPACIO ADECUADO
            gridHelperXY.rotateOnWorldAxis(x, THREE.Math.degToRad(90));
            gridHelperXZ.rotateOnWorldAxis(y, THREE.Math.degToRad(90));
            gridHelperYZ.rotateOnWorldAxis(z, THREE.Math.degToRad(90));

            //CREAR LAS FLECHAS QUE INDICAN LOS EJES DE COORDENADAS 3D
            var arrowX = new THREE.ArrowHelper(x, origin, arrowSize, colorR);
            var arrowY = new THREE.ArrowHelper(y, origin, arrowSize, colorG);
            var arrowZ = new THREE.ArrowHelper(z, origin, arrowSize, colorB);

            //CREAR LAS GEOMETRÍAS
            //Punto


            var altura = 20.0;
            var espiras = 20;
            var geoCubo = cubo(altura, espiras);



            //CREAR LOS MATERIALES
            var matLinea = new THREE.LineBasicMaterial({
                color: 0xFFFFFF
            });

            //CREAR LOS OBJETOS
            var cilindro = new THREE.Line(geoCubo, matLinea);

            //AGREGAR A LA ESCENA
            //scene.add( gridHelperXY );
            scene.add(gridHelperXZ);
            scene.add(arrowX);
            scene.add(arrowY);
            scene.add(arrowZ);
            scene.add(cilindro);

            camera.position.x = 5;
            camera.position.y = 10;
            camera.position.z = 10;

            camera.lookAt(origin);
        }
        function render(){
        var dtime = Date.now()-startTime;
        var tx=0, ty=0, tz=0;
        if(transf == 'E') {
            tx=1; ty=1; tz=1;
        }
        if(upArrow) {
            ty = (transf == 'T' ? 1 : transf == 'E' ? 1.1 : transf == 'R' ? 1 : 0);
        }
        if(downArrow) {
            ty = (transf == 'T' ? -1 : transf == 'E' ? 10/11 : transf == 'R' ? 1 : 0);
        }
        if(leftArrow) {
            tx=-1;
        }
        if(rightArrow) {
            tx=1;
        }
        if(homeKey) {
            tz=1;
        }
        if(endKey) {
            tz=-1;
        }
        if(clearKey) {
            tx=-object.position.x;
            ty=-object.position.y;
            tz=-object.position.z;
        }

        function animate() {
            render();
            requestAnimationFrame(animate);
        }

        function render() {
            var dtime = Date.now() - startTime;
            camera.position.x = 10 * Math.cos(dtime / 10000);
            camera.position.z = 10 * Math.sin(dtime / 10000);
            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }



        function cubo(altura, espiras) {
            var geoCubo = new THREE.Geometry();

            alt = altura;
            esp = espiras;


            for (var i = 0; i < alt; i++) {
                for (var ñ = 0; ñ < alt; ñ++) {
                    for (var j = 0; j < alt; j++) {
                        var punto = new THREE.Vector3();
                        punto.x = i / esp;
                        punto.y = j / esp;



                        geoCubo.vertices.push(punto);
                    }
                    punto.z = j / esp;

                }
                punto.y = 0;

            }
            return geoCubo;
        }


        function transfTS(s, t) {
        	m = new THREE.Matrix4();
        	sx = s.get(0);
        	sy = s.get(1);
        	sz = s.get(2);

        	m.set(sx, 0, 0, sx*tx,
        		0, sy, 0, sy*ty,
        		0, 0, sz, sz*tz
        		0, 0, 0, 1);
        	return m;

        }
    </script>
</body>

</html>